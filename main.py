'''
Project began on Apr 1st, 2022

@author: Jim Lakis
'''

import pandas as pd
import numpy as np
import itertools
import sys
import timeit
import statistics



def assign_col_percent_revenue_by_region_v2(df, revenue_sums_by_region_s):
    ''' Returns the original dataFrame with a new column that contains the percentage of Revenue by Region (Version 2)
    Author: J. Lakis
    '''
    df['Percent'] = 0.0
    for region in revenue_sums_by_region_s.index:
        for i in range(len(df)):
            if df.loc[i, 'Region'] == region:
                percent = df.loc[i, 'Revenue'] / revenue_sums_by_region_s[region]
                df.at[i, 'Percent'] = percent
    return df

def assign_col_percent_revenue_by_region(df, regions_l, revenue_sums_by_region_s):
    ''' Returns the original dataFrame with a new column that contains the percentage of Revenue by Region
    Author: J. Lakis
    '''
    df['Percent'] = 0.0
    for region in regions_l:
        for i in range(len(df)):
            if df.loc[i, 'Region'] == region:
                percent = df.loc[i, 'Revenue'] / revenue_sums_by_region_s[region]
                df.at[i, 'Percent'] = percent
    return df

def series_revenue_sums_by_region_v3(df):
    ''' Returns a series of the Revenue Sums by Region. (Version 3)
    Author: J. Lakis
    '''
    revenue_sums_by_region_s = pd.Series(dtype = float)
    for region in df['Region'].unique():
        revenue_sums_by_region_s[region] = df['Revenue'][df['Region'] == region].sum()
    return revenue_sums_by_region_s

def series_revenue_sums_by_region_v2(df):
    ''' Returns a series of the Revenue Sums by Region. (Version 2)
    Author: J. Lakis
    '''
    revenue_sums_by_region_s = pd.Series(dtype = float)
    for region in df['Region'].unique():
        x = 0
        for i in range(len(df)):
            if df.loc[i, 'Region'] == region:
                x += df.loc[i, 'Revenue']
        revenue_sums_by_region_s[region] = x
    return revenue_sums_by_region_s

def series_revenue_sums_by_region(df, regions_l):
    ''' Returns a series of the Revenue Sums by Region.
    Author: J. Lakis
    '''
    revenue_sums_by_region_s = pd.Series(dtype = float)
    for region in regions_l:
        x = 0
        for i in range(len(df)):
            if df.loc[i, 'Region'] == region:
                x = x + df.loc[i, 'Revenue']
        revenue_sums_by_region_s[region] = x
    return revenue_sums_by_region_s

def list_regions(df):
    ''' Returns a list of unique Regions.
    Author: J. Lakis
    '''
    regions_l = []
    for i in range(len(df)):
        if df.loc[i, 'Region'] not in regions_l:
            regions_l.append(df.loc[i, 'Region'])
    return regions_l


def lakis_version_three_B(df):
    ''' Returns the original dataframe with a new column added. The new column contains the percentage of Revenue generated by the various Teams and Squads within each Region.
    All of the steps, from determining the sums of the Revenues per Region, determining the Squads and Teams percentage contribution to total Revenues by Region and asigining those percentages to a new column are performed within the single original dataframe. The difference between this version and 3A is this version utilizes the df.where() method to employ a boolean mask. (No discernible time savings are found between 3A and 3B)
    Author: J. Lakis
    '''
    df['Percent_of_Regional_Revenue'] = pd.Series(np.nan, [i for i in list(range(len(df)))])    # add new column with elements initiallized with NaN
    
    for region in df['Region'].unique():
        mask = df['Region'] == region  # Boolean Mask for specific region
        df['Revenue_Bool_Index'] = df.where(mask)['Revenue']  # Boolean Indexing for specific region's Revenue
        df['Percent_of_Regional_Revenue_Bool_Index'] = df['Revenue_Bool_Index'] / df['Revenue_Bool_Index'].sum()
        df['Percent_of_Regional_Revenue'].update(df['Percent_of_Regional_Revenue_Bool_Index'])
        
    del [df['Revenue_Bool_Index'], df['Percent_of_Regional_Revenue_Bool_Index']]
    return df

def lakis_version_three_A(df):
    ''' Returns the original dataframe with a new column added. The new column contains the percentage of Revenue generated by the various Teams and Squads within each Region.
    All of the steps, from determining the sums of the Revenues per Region, determining the Squads and Teams percentage contribution to total Revenues by Region and asigining those percentages to a new column are performed within the single original dataframe. (No discernible time savings are found between 3A and 3B)
    Author: J. Lakis
    '''
    df['Percent_of_Regional_Revenue'] = pd.Series(np.nan, [i for i in list(range(len(df)))])    # add new column with elements initiallized with NaN
    
    for region in df['Region'].unique():
        df['Revenue_Bool_Index'] = df['Revenue'][df['Region'] == region]  # Boolean Indexing for specific region's Revenue
        df['Percent_of_Regional_Revenue_Bool_Index'] = df['Revenue_Bool_Index'] / df['Revenue_Bool_Index'].sum()
        df['Percent_of_Regional_Revenue'].update(df['Percent_of_Regional_Revenue_Bool_Index'])
        
    del [df['Revenue_Bool_Index'], df['Percent_of_Regional_Revenue_Bool_Index']]
    return df

def lakis_version_two_B(df):
    ''' Returns the original dataframe with a new column added. The new column contains the percentage of Revenue generated by the various Teams and Squads within each Region.
    Original work was not broken into seperate functions. (Version 2)
    Author: J. Lakis
    '''
    revenue_sums_by_region_s = series_revenue_sums_by_region_v3(df)
    new_df = assign_col_percent_revenue_by_region_v2(df, revenue_sums_by_region_s)
    return new_df

def lakis_version_two_A(df):
    ''' Returns the original dataframe with a new column added. The new column contains the percentage of Revenue generated by the various Teams and Squads within each Region.
    Original work was not broken into seperate functions. (Version 2)
    Author: J. Lakis
    '''
    revenue_sums_by_region_s = series_revenue_sums_by_region_v2(df)
    new_df = assign_col_percent_revenue_by_region_v2(df, revenue_sums_by_region_s)
    return new_df

def lakis_version_one(df):
    ''' Returns the original dataframe with a new column added. The new column contains the percentage of Revenue generated by the various Teams and Squads within each Region.
    Original work was not broken into seperate functions.
    Author: J. Lakis
    '''
    regions_l = list_regions(df)
    revenue_sums_by_region_s = series_revenue_sums_by_region(df, regions_l)
    new_df = assign_col_percent_revenue_by_region(df, regions_l, revenue_sums_by_region_s)
    return new_df

    
def instructors_version(df):
    ''' Returns the original dataframe with a new column added. The new column contains the percentage of Revenue generated by the various Teams and Squads within each Region.
    This is the course's instructor's solution.
    Author: xxxxxxxxx
    '''
    new_col = []
    for i in range(0, len(df)):
        rev = df['Revenue'][i] / df[ df['Region'] == df.loc[i, 'Region'] ] ['Revenue'].sum()
        new_col.append(rev)
    df['Revenue Share of Region'] = new_col
    return df


class ConcatCopyOfDfs:
    def __init__(self, df1: pd.DataFrame, number_of_copies: int):
        self._df1 = df1
        self._df2 = df1
        self._number_of_copies = number_of_copies
    
    @property
    def new_df(self):
        if self._number_of_copies == 1:
            return self._df1
        elif self._number_of_copies > 1:
            counter = 0
            while counter < self._number_of_copies - 1:
                self._df1 = pd.concat([self._df1, self._df2], ignore_index=True)
                counter += 1
        return self._df1
    
    def __str__(self):
        return f'{self.new_df}'
    
    
class OriginalDf:
    def __init__(self):
        self. _df = pd.DataFrame({
        "Region":['North','West','East','South','North','West','East','South'],
        "Team":['One','One','One','One','Two','Two','Two','Two'],
        "Squad":['A','B','C','D','E','F','G','H'],
        "Revenue":[7500,5500,2750,6400,2300,3750,1900,575],
        "Cost":[5200,5100,4400,5300,1250,1300,2100,50]
        })
        
    @property
    def df(self):
        return self._df


def main():


    # Instructors version ------------------------------------------

    setup ='from __main__ import pd; from __main__ import OriginalDf; from __main__ import ConcatCopyOfDfs; from __main__ import instructors_version'
    #stmt = ''
    
    t1 = timeit.timeit(setup = setup, stmt = """expanded_df = ConcatCopyOfDfs(OriginalDf().df, number_of_copies = 100).new_df;\
    instructors_df = instructors_version(expanded_df);\
    print(instructors_df.shape)""", number = 5)
    print(t1)
    #instructors_df = instructors_version(expanded_df)
    #print(instructors_df.sort_values(by = 'Region'))

    

    # J Lakis first version ------------------------------------------
    
    setup ='from __main__ import pd; from __main__ import OriginalDf; from __main__ import ConcatCopyOfDfs; from __main__ import lakis_version_one'
    #stmt = ''
    
    t2 = timeit.timeit(setup = setup, stmt = """expanded_df = ConcatCopyOfDfs(OriginalDf().df, number_of_copies = 100).new_df;\
    my_df = lakis_version_one(expanded_df);\
    print(my_df.shape)""", number = 5)
    print(t2)
    

    
    # J Lakis two version ------------------------------------------
    
    setup ='from __main__ import pd; from __main__ import OriginalDf; from __main__ import ConcatCopyOfDfs; from __main__ import lakis_version_two_A'
    #stmt = ''
    
    t3 = timeit.timeit(setup = setup, stmt = """expanded_df = ConcatCopyOfDfs(OriginalDf().df, number_of_copies = 100).new_df;\
    my_df = lakis_version_two_A(expanded_df);\
    print(my_df.shape)""", number = 5)
    print(t3)



    # J Lakis three version ------------------------------------------
    
    setup ='from __main__ import pd; from __main__ import OriginalDf; from __main__ import ConcatCopyOfDfs; from __main__ import lakis_version_three_B'
    #stmt = ''
    
    t4 = timeit.timeit(setup = setup, stmt = """expanded_df = ConcatCopyOfDfs(OriginalDf().df, number_of_copies = 100).new_df;\
    my_df = lakis_version_three_B(expanded_df);\
    print(my_df.shape)""", number = 5)
    print(t4)


if __name__ == '__main__':
    main()























    
    
'''


## Good side experiments

# 1
    def f(x):
        print(x)
    
    #print(ti.timeit('for x in range(10): f(x)', 'from __main__ import f', number = 1))
# --- end 1


# 2
    #ConcatCopyOfDfs(df1, 50).new_df
    #print(f'{sys.getsizeof(ConcatCopyOfDfs(df1, 500).new_df)/1000000} MB')
# --- end 2



# 3a
    #extended_df = concat_dfs(df1, 500)
    #print(f'{sys.getsizeof(extended_df)/1000000} MB')
# --- end 3a

# 3b
    #print(f'{sys.getsizeof(concat_dfs(df1, 500))/1000000} MB')
# --- end 3b


'''